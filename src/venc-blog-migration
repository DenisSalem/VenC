#! /usr/bin/python3

#    Copyright 2016, 2017 Denis Salem
#
#    This file is part of VenC.
#
#    VenC is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    VenC is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with VenC.  If not, see <http://www.gnu.org/licenses/>.

import os
import yaml
import codecs

from venc2.helpers import die
from venc2.helpers import notify
from venc2.datastore.entry import yield_entries_content
from venc2.l10n import messages

def ReplacePatterns(string):
    string = string.replace(".:Get::EntryID:.",".:GetEntryID:.")
    string = string.replace(".:Get::EntryName:.",".:GetEntryTitle:.")
    string = string.replace(".:Get::EntryMonth:.",".:GetEntryMonth:.")
    string = string.replace(".:Get::EntryYear:.",".:GetEntryYear:.")
    string = string.replace(".:Get::EntryDay:.",".:GetEntryDay:.")
    string = string.replace(".:Get::EntryHour:.",".:GetEntryHour:.")
    string = string.replace(".:Get::EntryMinute:.",".:GetEntryMinute:.")
    string = string.replace(".:Get::EntryCSS:",".:GetEntryMetadataIfExists::style:")

    string = string.replace(".:Get::AuthorName:.",".:GetAuthorName:.")
    string = string.replace(".:Get::BlogName:.",".:GetBlogName:.")
    string = string.replace(".:Get::BlogDescription:.",".:GetBlogDescription:.")
    string = string.replace(".:Get::BlogKeywords:.",".:GetBlogKeywords:.")
    string = string.replace(".:Get::AuthorDescription:.",".:GetAuthorDescription:.")
    string = string.replace(".:Get::License:.",".:GetBlogLicense:.")
    string = string.replace(".:Get::BlogUrl:.",".:GetBlogURL:.")
    string = string.replace(".:Get::BlogLanguage:.",".:GetBlogLanguage:.")
    string = string.replace(".:Get::AuthorEmail:.",".:GetAuthorEmail:.")
    string = string.replace(".:Get::RelativeOrigin:.",".:GetRelativeOrigin:.")
    string = string.replace(".:Get::RelativeLocation:.",".:GetRelativeLocation:.")
    
    string = string.replace(".:Get::EntryUrl:.",".:GetEntryURL:.")
    string = string.replace(".:Get::EntryContent:.",".:GetEntryContent:.")
    string = string.replace(".:Get::EntryDate:.",".:GetEntryDate:.")
    string = string.replace(".:Get::EntryDateUrl:.",".:GetEntryDateURL:.")
    
    string = string.replace(".:For::EntryTags:",".:ForEntryTags:")
    string = string.replace(".:For::BlogDates:",".:ForBlogDates:")
    string = string.replace(".:PagesList:",".:ForPages:")

    return string

def to_camel_case(name):
    chunks = name.split('_')
    if len(chunks) == 1:
        return name

    output = chunks[0].lower()
    
    for word in chunks[1:]:
        output += word.title()

    return output

''' Processing blog configuration '''

if not "blogConfiguration.yaml" in os.listdir():
    try:
        blog_configuration = yaml.load(open(os.getcwd()+"/blog_configuration.yaml",'r').read())

    except FileNotFoundError:
        die(messages.no_blog_configuration)

    except PermissionError:
        die(messages.no_blog_configuration)
        
    except yaml.scanner.ScannerError:
        die(messages.possible_malformed_blog_configuration)

    blog_configuration = dict()
    for rootkey in blog_configuration:
        if rootkey != "path":
            blog_configuration[ to_camel_case(rootkey) ] = blog_configuration[rootkey]

        else:
            blog_configuration["path"] = dict()
            for pathkey in blog_configuration["path"]:
                if pathkey == "entry_file_name":
                    blog_configuration["path"][ to_camel_case(pathkey) ] = blog_configuration["path"][pathkey].replace("{entry_id}","{0[entryId]}")

                elif pathkey == "index_file_name":
                    blog_configuration["path"][ to_camel_case(pathkey) ] = blog_configuration["path"][pathkey].replace("{page_number}","{0[pageNumber]}")

                else:
                    blog_configuration["path"][ to_camel_case(pathkey) ] = blog_configuration["path"][pathkey]

    blog_configuration.pop("threadOrder")
    blog_configuration["reverseThreadOrder"] = True

    stream = codecs.open('blogConfiguration.yaml', 'w',encoding="utf-8")
    yaml.dump(blog_configuration, stream, default_flow_style=False, allow_unicode=True)

''' Processing entries '''

for entry_filename in yield_entries_content():
    raw_data = open(os.getcwd()+"/entries/"+entryFilename,'r').read()
    try:
        metadata = yaml.load(raw_data.split("---\n")[0])
        metadata["title"] = metadata.pop("entry_name")

    except yaml.scanner.ScannerError:
        die(messages.possible_malformed_entry.format(entry_filename))

    except KeyError:
        if not "title" in metadata.keys():
            die(messages.possible_malformed_entry.format(entry_filename))
        else:
            pass

    output = yaml.dump(metadata, default_flow_style=False, allow_unicode=True) + "---\n"

    try:
        output += replace_patterns(rawData.split("---\n")[1])
    
    except IndexError:
        notify(messages.empty_entry.format(entry_filename), "YELLOW")
    
    stream = codecs.open("entries/"+entry_filename,'w',encoding="utf-8")
    stream.write(output)

''' Processing chunks '''

for chunk in os.listdir("theme/chunks"):
    raw_data = open("theme/chunks/"+chunk,'r').read()
    stream = codecs.open("theme/chunks/"+chunk,'w',encoding="utf-8")
    update = replace_patterns(raw_data)
    stream.write(update)


''' Cleaning '''

try:
    os.remove('blog_configuration.yaml')

except:
    pass
