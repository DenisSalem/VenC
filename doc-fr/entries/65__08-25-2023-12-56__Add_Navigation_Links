authors:
- 'Denis Salem'
categories:
- ''
title: Ajouter des liens de navigation
chapter: 7.5.4.3
---VENC-BEGIN-PREVIEW---
---VENC-END-PREVIEW---
Nous concluons la partie pied de page avec les liens de navigation. À noter que ce qui va suivre peut également être
programmé dans l'en-tête de votre site.

Comme on s'en doute votre blog n'affiche pas toutes les publications d'un fil sur une seule page. VenC utilise un système
de pagination que vous pouvez configurer [ici](.:GetChapterAttributeByIndex::path::3.2:.#entries-per-pages), en
conséquence il faut que le visiteur de votre site puisse naviguer entre ces différentes pages.

Pour cela on uitlise trois _motifs_ différents :

- [GetNextPage](.:GetChapterAttributeByIndex::path::4.3:.#getnextpage) : Permet de récupérer la page suivante si elle existe, sinon le _motif_ est ignoré.
- [GetPreviousPage](.:GetChapterAttributeByIndex::path::4.3:.#getpreviouspage) : Permet de récupérer la page précédente si elle existe, sinon le _motif_ est ignoré.
- [ForPages](.:GetChapterAttributeByIndex::path::4.3:.#forpages) : Permet de générer un liste de page numéroté. La page courange correspond à l'item central de la liste.

En reprenant l'exemple du chapitre précédent nous aurions alors aux lignes 8 à 12 :

.:CodeHighlight::HTML::True::        .:Escape::<footer>
            .:GetBlogMetadataIfExists::loading_image::
                <img id="__VENC_LOADING__" src=".:GetRelativeRoot:.{value}" />
            :.
            .:IncludeFileIfExists::
                .:GetBlogMetadataIfNotNull::include_in_footer:.        
            :.
            .:GetPreviousPage::<a id="previous_link" href="{path}">←</a>:.
            <ul id="navigation_pages_list">
                .:ForPages::5::<li class="page_list_item">
                    <a href="{page}">{page_number}</a>
                </li>:: . :.
            </ul>
            .:GetNextPage::<a id="next_link" href="{path}">→</a>:.
        </footer>:.
    </body>
</html>:.

- __Ligne 8__ et __ligne 14__ :  l'utilisation de [GetPreviousPage](.:GetChapterAttributeByIndex::path::4.3:.#getpreviouspage) et [GetNextPage](.:GetChapterAttributeByIndex::path::4.3:.#getnextpage) devrait être assez intuitive. En effet on utilise le _motif_
pour formatter le texte passé en argument à la fonction. Dans ce texte on utilise la variable {path} qui contient le chemin vers la page désiré.
- __Ligne 9__ et __ligne 13__ : On ouvre et ferme les balises de la liste HTML qui contiendra la liste des pages du fil de publication.
- __Lignes 10 à 12__ : Avec le _motif_ [ForPages](.:GetChapterAttributeByIndex::path::4.3:.#forpages) on indique le nombre de page que l'on souhaite faire apparaitre dans la liste,
dans le second argument, on formatte l'item à générer en utilisant les variable __path__ et __page_number__ qui contiennent respectivement le chemin vers la page cible ainsi que
son numéro (ligne 11).

À noter que si la page courante est la premiere ou la dernière page alors respectivement les _motifs_ [GetPreviousPage](.:GetChapterAttributeByIndex::path::4.3:.#getpreviouspage) et
[GetNextPage](.:GetChapterAttributeByIndex::path::4.3:.#getnextpage) seront ignorés et ne retournerons rien.

Notons également que si vous venez de commencer votre blog, il n'y aura probablement pas beaucoup de publication au début. Ces publications pourraient ne requiers
qu'une seule page pour êtres toutes affichés et il n'y aurait donc incidemment pas de liste de page à afficher non plus.

Du coup tout ça c'est pas mal. Mais on peut encore faire mieux.

Par exemple on voit bien que si au début votre site n'est pas très remplit
comme on l'a dit alors il n'y aura pas de liste de page à afficher et le _motif_ [ForPages](.:GetChapterAttributeByIndex::path::4.3:.#forpages) sera ignoré. Or les balises
HTML qui ouvrent et ferment la liste eux sont bien présent quoi qu'il arrive. On peut résoudre ce problème avec le _motif_ [IfPages](.:GetChapterAttributeByIndex::path::4.3:.#ifpages)
qui permet d'afficher ou non un bloc de texte selon qu'il y ai plusieurs pages ou non sur le fil de publication courant.

Il est également possible de controller l'affichage des boutons "suivant" ou précédent selon que l'on est dans une publication individuel sur une page donné d'un fil de publication.

Le code ci-dessous actualise ce qui a été déjà fait pour illustrer ces remarques.

.:CodeHighlight::HTML::True::        .:Escape::<footer>
            .:GetBlogMetadataIfExists::loading_image::
                <img id="__VENC_LOADING__" src=".:GetRelativeRoot:.{value}" />
            :.
            .:IncludeFileIfExists::
                .:GetBlogMetadataIfNotNull::include_in_footer:.        
            :.
            .:GetPreviousPage::<a id="previous_link" href="{path}">←</a>:.
            .:IfPages::
                <ul id="navigation_pages_list">
                    .:ForPages::5::<li class="page_list_item">
                        <a href="{page}">{page_number}</a>
                    </li>:: . :.
                </ul>
            :.
            .:GetNextPage::<a id="next_link" href="{path}">→</a>:.
        </footer>:.
    </body>
</html>:.

